<script>
    window.sirius = window.sirius || {};

    function asFunction(possibleFunction) {
        return typeof possibleFunction === "function" ? possibleFunction : Function();
    }


    /**
     * Provides a simple api to use the tokenfield lib.
     *
     * Will handle the two different input fields (the actual one and the one the lib generates).
     *
     * @@type {{eventNames, on, start, getInput, appendTokens, getInputFieldId, hasTokens}}
     */
    sirius.tokenfield = (function () {
            var input = {
                id: undefined,

                /**
                 * the actual input field
                 */
                element: undefined,

                /**
                 * the generated input field by the tokenfield library
                 */
                tokenElement: undefined,

                value: "",
                allTokens: undefined,

                /**
                 * Keys of the config object are:
                 * - id (of the input field)
                 * - tokenfield: the tokenfield config object: see http://sliptree.github.io/bootstrap-tokenfield/
                 */
                init: function (config) {
                    this.id = config.id;

                    if (this.id === undefined) {
                        throw "The start config must define the property 'id'";
                    }

                    this.element = $("#" + this.id);
                    this.value = this.element.val();
                    var tokenfieldConfig = $.extend({delimiter: " "}, config.tokenfield );
                    this.element.tokenfield(tokenfieldConfig);

                    this.tokenElement = $("#" + this.id + "-tokenfield");

                    // delete the element value because they are tokens now and the value should not be displayed twice
                    this.tokenElement.val("");

                    // create initial tokens
                    $.each(this.value.split(tokenfieldConfig.delimiter), function(index, element)Â {
                        this.allTokens = [{label: element, value: element, initialQueryIdentifier: true}];
                    });

                    this.element.on('tokenfield:removedtoken', function (e) {
                        var identifier = e.attrs.value;
                        $('input[data-identifier="' + identifier + '"]').remove();

                        if (e.attrs.initialQueryIdentifier) {
                            input.value = "";
                        }

                        // remove the token from the tokens array as well
                        input.allTokens = $.grep(input.allTokens, function (token) {
                            return identifier !== token.value;
                        });

                        events.onRemovedToken(e);
                    });

                    this.tokenElement.keydown(function (e) {
                        if (e.keyCode === sirius.keys.KEY_ENTER) {
                            events.onEnter(e);
                        }
                    });

                    $( window ).resize(function(e) {
                        input.resize(e);
                    });
                },

                /**
                 * Returns the full value of the input field.
                 *
                 * This includes the current user input and the tokenized value.
                 */
                getValue: function () {
                    return this.value + " " + this.tokenElement.val();
                },

                /**
                 * Adds a list of tokens to the already existing once.
                 *
                 * @@param tokens array of tokens to be added
                 */
                appendTokens: function (tokens) {
                    this.allTokens = this.allTokens.concat(tokens);
                    this.element.tokenfield("setTokens", this.allTokens);
                },

                resize: function(e){
                    events.onResize(e);
                }
            };

            var events = {
                onEnter: Function(),
                onRemovedToken: Function(),
                onResize: Function()
            };

            return {
                eventNames: function () {
                    return Object.keys(events);
                },

                /**
                 * Adds event handlers.
                 *
                 * Each event handler can be set only once.
                 *
                 * @@param name of the event
                 * @@param callback the function to be executed if the event is triggered
                 */
                on: function (name, callback) {
                    if (this.eventNames().includes(name)) {
                        events[name] = asFunction(callback);
                    } else {
                        throw "Callback " + name + " is no valid event.";
                    }
                },

                start: function (config) {
                    input.init(config);
                },

                getInput: function () {
                    return input.getValue();
                },

                appendTokens: function (tokens) {
                    input.appendTokens(tokens);
                },

                getInputFieldId: function () {
                    return input.tokenElement.prop("id");
                },

                getInputField: function(){
                    return input.element;
                },

                getTokenfieldInputField: function(){
                    return input.tokenElement;
                },

                hasTokens: function () {
                    return input.element.tokenfield('getTokens').length > 0;
                }
            };
        }
    )();
</script>
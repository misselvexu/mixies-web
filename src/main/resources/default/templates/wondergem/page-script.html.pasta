<script type="text/javascript">
    function createConfirmForDangerousLinks() {
        $("a.link-danger, a.button-danger-ask").on('click', function (event) {
            if ($(this).hasClass("guarded-link")) {
                try {
                    var modalElement = $("#danger-link-confirm");
                    var submitBtn = modalElement.find(":submit");
                    var that = $(this);

                    submitBtn.click(function () {
                        $("#" + that.data("deleteid")).submit();
                    });

                    modalElement.modal({
                        keyboard: true
                    }).on("hide", function () {
                        modalElement.find(":submit").unbind("click");
                    }).on("shown", function () {
                        modalElement.find(".btn-close").focus();
                    }).attr("tabindex", -1);
                } catch ($e) {
                    console.log($e);
                }

                return false;
            } else {
                try {
                    var clickedLink = event.currentTarget;
                    var modalElement = $("#danger-link-confirm");

                    var okayLink = $(clickedLink).attr('href');
                    var submitBtn = modalElement.find(":submit");

                    submitBtn.click(function () {
                        window.location.href = okayLink;
                    });

                    modalElement.modal({
                        keyboard: true
                    }).on("hide", function () {
                        modalElement.find(":submit").unbind("click");
                    }).on("shown", function () {
                        modalElement.find(".btn-close").focus();
                    }).attr("tabindex", -1);
                } catch ($e) {
                    console.log($e);
                }

                return false;
            }
        });
    }

    function instanciateColorPickers() {
        $('.pick-a-color').colorpicker();
    }

    var select2Translations = {
        loadingMore: function () {
            return '@i18n("template.html.select2.loading")';
        },
        searching: function () {
            return '@i18n("template.html.select2.searching")';
        },
        noResults: function () {
            return '@i18n("template.html.select2.noMatches")';
        },
        errorLoading: function () {
            return '@i18n("template.html.select2.errorLoading")';
        }
    };

    var AUTOCOMPLETE_SUGGESTION_TEMPLATE =
        '<span>' +
        '   {{label}}' +
        '   {{#hasDescription}}' +
        '      <div class="suggestion-description">' +
        '      {{#descriptionLines}}' +
        '          {{.}}<br>' +
        '      {{/descriptionLines}}' +
        '      </div>' +
        '   {{/hasDescription}}' +
        '</span>';

    function enableAutocomplete(field) {
        function createSubmitData(key, value) {
            var data = {};
            var fieldData = field.data();
            for (f in fieldData) {
                if (fieldData.hasOwnProperty(f)) {
                    if (f != 'autocomplete'
                        && f != 'optional'
                        && f != 'select2') {
                        data[f] = fieldData[f];
                    }
                }
            }
            data[key] = value;
            return data;
        }

        if (field.data('optional')) {
            field.prepend('<option value=""></option>');
        }

        field.on('select2:open', function (e) {
            $('.select2-search__field').each(function (e) {
                var search = $(this);
                if (search.parent().hasClass('select2-search--inline')) {
                    // Don't add placeholder and graphic to inline search fields
                    return;
                }
                search.css({
                    'background-image': 'url("/assets/wondergem/select2/chosen-sprite.png")',
                    'background-repeat': 'no-repeat',
                    'background-position': '100% -22px'
                });

                ___if(!call.getUserAgent().isInternetExplorer())
                {
                    var placeholder = field.attr('data-searchtext');
                    if (typeof placeholder === 'undefined' || placeholder === '') {
                        placeholder = '@i18n("template.html.placeholder")';
                    }
                    search.attr('placeholder', placeholder);
                }
            });
        });

        field.on('select2:unselect', function (e) {
            $(this).html('<option value=""></option>');
            e.preventDefault();
            e.stopPropagation();
        });

        field.select2({
            allowClear: field.data('optional'),
            placeholder: '@i18n("template.html.select2.selection")',
            dropdownParent: field.parent(),
            minimumInputLength: 0,
            tags: field.data('dynamic-option'),
            templateResult: function (result) {
                if (typeof result === 'undefined') {
                    return undefined;
                }

                var hasDescription = typeof result.description !== 'undefined' && result.description !== '';

                if (field.attr('data-multiline')) {
                    return $(Mustache.render(AUTOCOMPLETE_SUGGESTION_TEMPLATE, {
                        'label': result.text,
                        'hasDescription': hasDescription,
                        'descriptionLines': hasDescription ? result.description.split('\n') : undefined
                    }));
                }

                return hasDescription ? result.description : result.text;
            },
            language: select2Translations,
            ajax: {
                url: field.data('autocomplete'),
                dataType: 'jsonp',
                quietMillis: 100,
                data: function (term, page) {
                    return createSubmitData('query', term.term);
                },
                processResults: function (data, page) {
                    return {results: data.completions, more: false};
                }
            }
        });
    }

    $(document).ready(function () {
        createConfirmForDangerousLinks();
        instanciateColorPickers();

        $('.date-picker').datepicker({
            format: '@dateFormat',
            todayBtn: true,
            language: "@lang",
            autoclose: true,
            todayHighlight: true
        });

        $('select[data-autocomplete]').each(function (e) {
            var field = $(this);

            enableAutocomplete(field);
        });

        $('.select2-select').each(function (e) {
            var field = $(this);

            if (field.data('optional')) {
                field.prepend('<option value=""></option>');
            }

            field.select2({
                allowClear: field.data('optional'),
                placeholder: '@i18n("template.html.select2.selection")',
                dropdownParent: field.parent(),
                tags: field.data('dynamic-option'),
                minimumResultsForSearch: 10,
                width: '100%',
                language: select2Translations,
                escapeMarkup: function (m) {
                    // Do not escape HTML in the select options text
                    return m;
                }
            });
        });

        $(window).resize(invokeResizeHandler);
        invokeResizeHandler();
    });

    if (typeof window.console === "undefined") {
        window.console = {
            log: function (msg) {
            }
        };
    }

    function invokeResizeHandler() {
        try {
            if (typeof handleResize === 'function') {
                // Invoke custom handler
                handleResize();
            } else {
                var newHeight = $(window).height() - $('.footer').outerHeight() - $('#mainContainer').position().top;
                $('#mainContainer').css('min-height', newHeight + 'px');
            }
        } catch (e) {
            console.log(e);
        }
    }

    function addInfo(message, action, actionLabel) {
        if (action) {
            $('<div class="alert alert-info">' + message + ' <a class="link link-info" href="' + action + '">' + actionLabel + '</a></div>').appendTo($('#messageBox'));
        } else {
            $('<div class="alert alert-info"></div>').html(message).appendTo($('#messageBox'));
        }
    }

    function addError(message) {
        $('<div class="alert alert-danger"></div>').html(message).appendTo($('#messageBox'));
    }

    function clearMessages() {
        $('#messageBox').html('');
    }

    function autoUpdate(reloadUrl) {
        var yscroll = getUrlParameters(window.location.href)['yscroll'];
        if (typeof yscroll !== 'undefined') {
            $(window).scrollTop(yscroll);
        }
        setTimeout(function () {
            var yscroll = $(window).scrollTop();
            if (yscroll > 0) {
                var params = getUrlParameters(decodeURIComponent(reloadUrl).replace(/\+/g, '%20'));
                params['yscroll'] = yscroll;
                reloadUrl = reloadUrl.split('?')[0] + '?' + $.param(params);
            }
            window.location.replace(reloadUrl);
        }, 10000);
    }

    function getUrlParameters(url) {
        var params = {}, param;
        var query = url.split('?')[1];
        if (query !== undefined) {
            query = query.split('&');
            for (var i = 0; i < query.length; i++) {
                param = query[i].split('=');
                params[param[0]] = param[1];
            }
        }
        return params;
    }

    function imageUpload(url, target, defaultPreview, defaultImage, allowedExtensions) {
        var container = target;
        new qq.FileUploader({
            element: target,
            action: url,
            debug: false,
            onComplete: function (cmp_id, fileName, responseJSON) {
                clearMessages();
                if (responseJSON.error) {
                    addError(responseJSON.message);
                } else if (responseJSON.message) {
                    addInfo(responseJSON.message);
                }
                if (responseJSON.previewUrl) {
                    $('.img', container).attr('src', responseJSON.previewUrl);
                    $('.lnk', container).attr('href', responseJSON.imageUrl);
                }
                if (responseJSON.redirect) {
                    setTimeout(function () {
                        window.location = responseJSON.redirect;
                    }, 1250);
                }
            },
            showMessage: function (message) {
                // We generally send a flag "error" which is true or false as
                // part of the response. Sadly, fileUploader.js checks for this
                // flag (expecting a string) and invokes showMessage is present.
                // Therefore we have to filter this here :-/
                if (message !== true) {
                    clearMessages();
                    addError(message);
                }
            },
            messages: {
                typeError: '@i18n("template.html.errInvalidExtension")',
                sizeError: '@i18n("template.html.errTooLarge")',
                minSizeError: '@i18n("template.html.errTooSmall")',
                emptyError: '@i18n("template.html.errEmpty")'
            },
            allowedExtensions: allowedExtensions,
            template: '<div class="qq-uploader">' +
                '<div class="qq-upload-drop-area qq-image-area"><div><span style="display: inline-block"><a href="' + defaultImage + '" class="thumbnail lnk"><img class="img" src="' + defaultPreview + '" /></a></span></div><span>@i18n("template.html.uploadArea")</span></div>' +
                '<div class="qq-upload-button btn btn-primary" style="display: block">@i18n("template.html.uploadBtn")</div>' +
                '<ul class="qq-upload-list"></ul>' +
                '</div>',
            fileTemplate: '<li>' +
                '<span class="qq-upload-file"></span>' +
                '<span class="qq-upload-spinner"></span>' +
                '<span class="qq-upload-size"></span>' +
                '<a class="qq-upload-cancel" href="#">@i18n("NLS.cancel")</a>' +
                '<span class="qq-upload-failed-text">@i18n("template.html.uploadFailed")</span>' +
                '</li>'
        });
        var maxWidth = $(container).width();
        $('.img', container).css('max-width', maxWidth - 30 + 'px');
    }

    function fileUpload(url, target, params, allowedExtensions, maxParallelConnections) {
        var container = target;

        new qq.FileUploader({
            element: target,
            action: url,
            params: params,
            debug: false,
            maxConnections: maxParallelConnections || 3,
            onComplete: function (cmp_id, fileName, responseJSON) {
                clearMessages();
                if (responseJSON.error) {
                    addError(responseJSON.message);
                } else if (responseJSON.message) {
                    if (responseJSON.action) {
                        addInfo(responseJSON.message, responseJSON.action, responseJSON.actionLabel);
                    } else {
                        addInfo(responseJSON.message);
                    }
                }
                if (responseJSON.refresh) {
                    setTimeout(function () {
                        var editForm = $('#editForm');
                        if (editForm.length) {
                            $('#uploadedFile').val(responseJSON.fileId);
                            editForm.submit();
                        } else {
                            window.location.reload();
                        }
                    }, 1250);
                }
            },
            showMessage: function (message) {
                // We generally send a flag "error" which is true or false as
                // part of the response. Sadly, fileUploader.js checks for this
                // flag (expecting a string) and invokes showMessage is present.
                // Therefore we have to filter this here :-/
                if (message !== true) {
                    clearMessages();
                    addError(message);
                }
            },
            messages: {
                typeError: '@i18n("template.html.errInvalidExtension")',
                sizeError: '@i18n("template.html.errTooLarge")',
                minSizeError: '@i18n("template.html.errTooSmall")',
                emptyError: '@i18n("template.html.errEmpty")'
            },
            allowedExtensions: allowedExtensions,
            template: '<div class="qq-uploader">' +
                '<div class="qq-upload-drop-area"><span>@i18n("template.html.uploadArea")</span></div>' +
                '<div class="qq-upload-button btn btn-primary" style="display: block">@i18n("template.html.uploadBtn")</div>' +
                '<ul class="qq-upload-list"></ul>' +
                '</div>',
            fileTemplate: '<li>' +
                '<span class="qq-upload-file"></span>' +
                '<span class="qq-upload-spinner"></span>' +
                '<span class="qq-upload-size"></span>' +
                '<a class="qq-upload-cancel" href="#">@i18n("NLS.cancel")</a>' +
                '<span class="qq-upload-failed-text">@i18n("template.html.uploadFailed")</span>' +
                '</li>'
        });
    }

    function updateField(url, field, value) {
        var data = {};
        data[field] = value;
        $.post(url,
            data,
            function (json) {
                clearMessages();
                if (json.error) {
                    addError(json.message);
                } else {
                    addInfo('@i18n("BasicController.changesSaved")');
                }
            }, 'json');
    }

    $(function () {
        $('.submit-link').click(function () {
            if (!$(this).hasClass("single-click-pending")) {
                $('#editForm').submit();
            }
        });
        $('.single-click-link').click(function (e) {
            var a = $(this);
            if (a.hasClass("single-click-pending")) {
                e.preventDefault();
                return false;
            }
            a.addClass("single-click-pending");
        });
    });

    var CHART_COLORS = ["#5cbae6", "#fac364", "#b6d957", "#8cd3ff", "#d998cb", "#f2d249", "#93b9c6", "#ccc5a8", "#52bacc", "#dbdb46", "#98aafb"];
    var LINE_CHART_DEFAULT_OPTIONS = {
        responsive: true,
        maintainAspectRatio: false,
        bezierCurve: true,
        legend: {display: false},
        scales: {
            yAxes: [{
                ticks: {
                    beginAtZero: true,
                }
            }],
            xAxes: [{
                ticks: {
                    autoSkip: false
                }
            }]
        }
    };

    function lineChart(selector, labels, datasets) {
        var lineData = [];
        for (var i = 0; i < datasets.length; i++) {
            var color = CHART_COLORS[i % CHART_COLORS.length];
            lineData.push({
                backgroundColor: "rgba(180,180,180,0.2)",
                borderColor: color,
                pointColor: color,
                pointStrokeColor: "#fff",
                pointHighlightFill: "#fff",
                pointHighlightStroke: color,
                label: datasets[i].label,
                data: datasets[i].data
            });
        }
        new Chart($(selector).get(0).getContext("2d"),
            {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: lineData
                },
                options: $.extend(LINE_CHART_DEFAULT_OPTIONS, {legend: {display: datasets.length > 1}})
            });
    }

    function barChart(selector, labels, datasets) {
        var barData = [];
        for (var i = 0; i < datasets.length; i++) {
            var color = CHART_COLORS[i % CHART_COLORS.length];
            barData.push({
                backgroundColor: color,
                borderColor: color,
                pointColor: color,
                pointStrokeColor: "#fff",
                pointHighlightFill: "#fff",
                pointHighlightStroke: color,
                label: datasets[i].label,
                data: datasets[i].data
            });
        }
        new Chart($(selector).get(0).getContext("2d"),
            {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: barData
                },
                options: $.extend(LINE_CHART_DEFAULT_OPTIONS, {legend: {display: datasets.length > 1}})
            });
    }

    function polarAreaChart(selector, labels, data) {
        new Chart($(selector).get(0).getContext("2d"), {
            data: {
                datasets: [{
                    data: data,
                    backgroundColor: CHART_COLORS
                }],
                labels: labels
            },
            type: 'polarArea',
            options: {
                startAngle: -0.55 * Math.PI
            }
        });
    }

    function dougnutChart(selector, labels, data) {
        new Chart($(selector).get(0).getContext("2d"), {
            data: {
                datasets: [{
                    data: data,
                    backgroundColor: CHART_COLORS
                }],
                labels: labels
            },
            type: 'doughnut',
            options: {
                startAngle: -0.55 * Math.PI
            }
        });
    }

    $(document).ready(function () {
        $('.sparkline').each(function () {
            var $this = $(this);
            var element = $this.get(0);
            sparkline(element);
        });
    });

    var multiSelect = function (args) {
        var createSuggestionsObject = function (selectId) {
            var allSuggestions = [];
            var initialSelection = [];

            var $select = $('#' + selectId);
            for (var i = 0; i < $select[0].options.length; i++) {
                var option = $select[0].options[i];
                var token = {
                    label: option.text,
                    value: option.value
                };
                allSuggestions.push(token);
                if (option.selected) {
                    initialSelection.push(token);
                }
            }
            $select.remove();

            return {
                getAllSuggestions: function () {
                    return allSuggestions;
                },
                getInitialSelection: function () {
                    return initialSelection;
                },
                addSuggestion: function (token) {
                    allSuggestions.push(token)
                },
                forEachMatchingSuggestion: function (query, callback) {
                    var found = undefined;
                    $.each(allSuggestions, function (i, element) {
                        if (element.label.toLowerCase().indexOf(query.toLowerCase()) !== -1 ||
                            element.value.toLowerCase().indexOf(query.toLowerCase()) !== -1) {
                            if (callback) {
                                callback(element);
                            }
                        }
                    });
                    return found;
                },
                getTokenForValue: function (value) {
                    var token = undefined;
                    $.each(allSuggestions, function (i, element) {
                        if (element.value === value) {
                            token = element;
                        }
                    });
                    return token;
                }
            }
        }

        var autocompleteTemplates = {
            basic:
                '<div class="autocomplete-row autocomplete-selectable-element autocomplete-row-js' +
                '            {{#inTokenfield}}in-token-field{{/inTokenfield}}"> ' +
                '   <span class="element-heading">{{label}}</span>' +
                '   <span class="autocomplete-data" data-autocomplete="{{value}}" style="display: none"></span>' +
                '</div>'
        }

        var suggestions = createSuggestionsObject(args.id + '-suggestions-select');

        var tokenfield = sirius.createTokenfield();
        var autocomplete = sirius.createAutocomplete();

        autocomplete.on('onHoverRow', function ($row) {
            autocomplete.getInput().val($row.find('.autocomplete-data').data('autocomplete'));
        });

        autocomplete.on('onUnhoverRow', function ($row) {
            autocomplete.getInput().val('');
        });

        autocomplete.on('onReady', function ($row) {
            tokenfield.on('onBeforeCreateToken', function (token) {
                // hide the autocomplete imediately, because else "dragging" over the completions will introduce unwanted
                // state, e.g. text of a compeltions-row is in input field, but not created as token
                autocomplete.hide();
                return true;
            });
        });

        autocomplete.on('beforeRenderRow', function (row) {
            row.inTokenfield = tokenfield.hasToken(row);
        });

        tokenfield.on('onBeforeCreateToken', function (token) {
            if (tokenfield.hasToken(token)) {
                tokenfield.removeToken(token);
                return false;
            }
            if (!suggestions.getTokenForValue(token.value)) {
                if (args.allowCustomEntries) {
                    suggestions.addSuggestion(token);
                } else {
                    return false;
                }
            } else {
                token.label = suggestions.getTokenForValue(token.value).label;
            }
            return true;
        });

        tokenfield.start({
            id: args.id + '-input',
            showRemovalElement: false,
            hiddenInputsName: args.name,
            tokenfield: {
                delimiter: args.delimiter || '|',
                createTokensOnBlur: true,
                limit: args.maxItems
            }
        });

        tokenfield.appendTokens(suggestions.getInitialSelection());

        if (!args.readonly) {
            var noMatchesToken = {label: args.noMatchesText, type: 'basic'};

            var autocompleteArgs = {
                inputField: tokenfield.getInputFieldId(),
                anchor: '#' + args.id + ' .tokenfield',
                templates: autocompleteTemplates,
                completions: {
                    id: args.id + '-completion',
                    height: '300px'
                }
            };

            if (args.serviceUri) {
                autocomplete.on("afterLoad", function (value, response) {
                    var responseTokens = [];
                    response.completions.forEach(function (completion) {
                        responseTokens.push({
                            // label is the text displayed in the dropdown. should be what is given as "description"
                            // by the service. but use other texts as fallback.
                            label: completion.description || completion.text || completion.id,
                            value: completion.id,
                            type: 'basic'
                        });

                        if (!suggestions.getTokenForValue(completion.id)) {
                            suggestions.addSuggestion({
                                // label is the text displayed in the tokenfield. should be what is given as "text"
                                // by the service. but use other texts as fallback.
                                label: completion.text || completion.description || completion.id,
                                value: completion.id
                            });
                        }
                    });
                    if (responseTokens.length === 0) {
                        responseTokens.push(noMatchesToken);
                    }
                    return responseTokens;
                });

                autocompleteArgs.service = {
                    serviceUri: args.serviceUri,
                    minSize: 0,
                    delay: 0,
                    getRequest: function (inputValue) {
                        var requestParams = {query: inputValue || '', strict: !args.allowCustomEntries};
                        if (args.type) {
                            requestParams.type = args.type;
                        }
                        return requestParams;
                    }
                }
            } else {
                autocompleteArgs.localSource = {
                    callback: function (query) {
                        var rows = [];
                        if (args.allowCustomEntries && query && !suggestions.getTokenForValue(query)) {
                            rows.push({
                                label: query,
                                value: query,
                                type: 'basic'
                            });
                        }
                        suggestions.forEachMatchingSuggestion(query, function (element) {
                            rows.push({
                                label: element.label,
                                value: element.value,
                                type: 'basic'
                            });
                        });
                        if (rows.length === 0) {
                            rows.push(noMatchesToken);
                        }
                        return rows;
                    }
                }
            }

            autocomplete.start(autocompleteArgs);
        } else {
            // add the 'disabled' class to the tokenfield, so it looks grey and 'disabled'
            // we have to add that manually, because just 'readonly' does not look like that for the tokenfield
            // but we also don't want to disable the field, because in some browsers disabled fields are not sent when
            // posting
            $('#' + args.id + ' .tokenfield').addClass('disabled');
        }
    };
</script>

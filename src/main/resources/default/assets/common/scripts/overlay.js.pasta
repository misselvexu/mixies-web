(function (overlay) {
    const template = '<div class="sci-overlay-background">' +
        '    <div class="sci-overlay">' +
        '        <div class="sci-overlay-infobar">' +
        '            <div class="sci-overlay-infobar-left">' +
        '                <span class="sci-overlay-infobar-name">' +
        '                    {{name}}' +
        '                </span>' +
        '            </div>' +
        '            <div class="sci-overlay-infobar-right">' +
        '                <div>' +
        '                    <a role="button" class="sci-overlay-button sci-overlay-button-close sci-overlay-button-close-js"></a>' +
        '                </div>' +
        '            </div>' +
        '        </div>' +
        '        <div class="sci-overlay-content-outer-container">' +
        '            <div class="sci-overlay-content-inner-container">' +
        '               <div class="sci-overlay-content">' +
        '                   {{{content}}}' +
        '               </div>' +
        '           </div>' +
        '       </div>' +
        '   </div>' +
        '</div>';

    const overlayStack = [];

    /**@
     * Creates and shows a new overlay.
     * <p>
     * If one or more overlays already exist, the new overlay will be shown on top of already existing overlays.
     *
     * @param args object containing at least all required fields:
     *              - name:    name to be displayed in the infobar
     *              - content: html content that will be rendered inside the overlay
     */
    overlay.createAndShowOverlay = function (args) {
        const _html = Mustache.render(template, args);
        const _overlayContainer = document.createElement('div');
        _overlayContainer.innerHTML = _html;

        const _overlay = _overlayContainer.firstChild;

        _overlay.querySelector('.sci-overlay-button-close-js').addEventListener('click', function () {
            overlay.destroyOverlay();
        });

        _overlay.addEventListener('click', function (event) {
            if (event.target === _overlay) {
                overlay.destroyOverlay();
            }
        });

        overlayStack.push(_overlay);

        if (overlayStack.length === 1) {
            _overlay.classList.add('first');
            document.documentElement.classList.add('sci-overlay-static-body');
        }

        window.addEventListener('keyup', destroyOverlayEventHandler);

        document.body.appendChild(_overlay);

        // We replace the code in the added node with a clone, so it will get automatically executed.

        function nodeScriptReplace(_node) {
            if (_node.tagName === 'SCRIPT') {
                _node.parentNode.replaceChild(nodeScriptClone(_node), _node);
            } else {
                for (let i = 0; i < _node.childNodes.length; i++) {
                    nodeScriptReplace(_node.childNodes[i]);
                }
            }

            return _node;
        }

        function nodeScriptClone(_node) {
            const _script = document.createElement("script");
            _script.text = _node.innerHTML;

            for (let i = 0; i < _node.attributes.length; i++) {
                let attribute = _node.attributes[i];
                _script.setAttribute(attribute.name, attribute.value);
            }
            return _script;
        }

        nodeScriptReplace(_overlay);
    }

    overlay.destroyOverlay = function () {
        const _overlay = overlayStack.pop();

        if (_overlay) {
            _overlay.parentElement.removeChild(_overlay);
        }

        if (overlayStack.length === 0) {
            window.removeEventListener('keyup', destroyOverlayEventHandler);
            document.documentElement.classList.remove('sci-overlay-static-body');
        }
    }

    const destroyOverlayEventHandler = function (event) {
        if (event.key === 'Escape') {
            overlay.destroyOverlay();
        }
    }
}(window.sirius.overlay = window.sirius.overlay || {}));

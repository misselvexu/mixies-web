/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.web.templates;

import sirius.kernel.Sirius;
import sirius.kernel.cache.Cache;
import sirius.kernel.cache.CacheManager;
import sirius.kernel.di.std.PriorityParts;
import sirius.kernel.di.std.Register;
import sirius.kernel.health.Log;
import sirius.web.security.UserContext;

import javax.annotation.Nonnull;
import java.util.Collection;
import java.util.Objects;
import java.util.Optional;

/**
 * Content generator which generates output based on templates.
 * <p>
 * In contrast to the web server and its handlers Velocity is used here as template engine. This is because
 * these templates are easier to write as they don't need andy type information. as these templates are less
 * frequently executed the lower performance does not matter. The language reference of velocity, which is one of the
 * most commonly used language for templates can be found here:
 * http://velocity.apache.org/engine/devel/vtl-reference-guide.html
 * <p>
 * The template sources are loaded via {@link #resolve(String)}. If no resolver is available or none of the
 * available ones can load the template, it is tried to load the template from the classpath.
 * <p>
 * To extend the built in velocity engine, macro libraries can be enumerated in the system config under
 * <b>content.velocity-libraries</b> (For examples see component-web.conf). Also {@link ContentContextExtender} can
 * be implemented and registered in order to provider default variables within the execution context.
 * <p>
 * Specific output types are generated by {@link ContentHandler} implementations. Those are either picked by the file
 * name of the template, or by setting {@link Generator#handler(String)}. So if a file ends with <b>.pdf.vm</b> it is
 * first evaluated by velocity (expecting to generate XHTML) and then rendered to a PDF by flying saucer.
 * Alternatively the handler type <b>pdf-vm</b> can be set to ensure that this handler is picked.
 */
@Register(classes = Resources.class)
public class Resources {

    /*
     * Logger used by the resource discovery framework
     */
    public static final Log LOG = Log.get("resources");

    @PriorityParts(Resolver.class)
    private Collection<Resolver> resolvers;

    /**
     * Cache used to map a scope name and local uri to an URL pointing to a resolved content.
     */
    private Cache<String, Optional<Resource>> resolverCache = CacheManager.createCache("resolver-cache");

    /**
     * Tries to resolve a template or content-file into a {@link Resource}
     *
     * @param uri the local name of the uri to load
     * @return a {@link Resource} (wrapped as resource) pointing to the requested content
     * or an empty optional if no resource was found
     */
    @Nonnull
    public Optional<Resource> resolve(@Nonnull String uri) {
        return resolve(UserContext.getCurrentScope().getScopeId(), uri);
    }

    /**
     * Tries to resolve a template or content-file into a {@link Resource}
     *
     * @param scopeId the scope to use. Use {@link #resolve(String)} to pick the currently active scope
     * @param uri     the local name of the uri to load
     * @return a {@link Resource} (wrapped as resource) pointing to the requested content
     * or an empty optional if no resource was found
     */
    @Nonnull
    public Optional<Resource> resolve(@Nonnull String scopeId, @Nonnull String uri) {
        String lookupKey = scopeId + "://" + uri;
        Optional<Resource> result = resolverCache.get(lookupKey);
        if (result != null) {
            if (Sirius.isDev()) {
                // In dev environments, we always perform a lookup in case something changed
                Optional<Resource> currentResult = resolveURI(scopeId, uri);
                if (!result.isPresent()) {
                    return currentResult;
                }
                if (!currentResult.isPresent() || !Objects.equals(result.get().getUrl(),
                                                                  currentResult.get().getUrl())) {
                    return currentResult;
                }
            }
            return result;
        }
        result = resolveURI(scopeId, uri);
        resolverCache.put(lookupKey, result);
        return result;
    }

    /*
     * Calls all available resolvers to pick the right content for the given scope and uri (without using a cache)
     */
    private Optional<Resource> resolveURI(String scopeId, String uri) {
        if (!uri.startsWith("/")) {
            uri = "/" + uri;
        }
        for (Resolver res : resolvers) {
            Resource r = res.resolve(scopeId, uri);
            if (r != null) {
                return Optional.of(r);
            }
        }
        return Optional.empty();
    }
}

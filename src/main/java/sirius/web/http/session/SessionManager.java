/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.web.http.session;

import com.google.common.collect.Maps;
import sirius.kernel.commons.Lambdas;
import sirius.kernel.commons.Strings;
import sirius.kernel.di.PartCollection;
import sirius.kernel.di.std.Part;
import sirius.kernel.di.std.Parts;
import sirius.kernel.di.std.Register;
import sirius.kernel.timer.EveryTenMinutes;

import javax.annotation.Nullable;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.stream.Stream;

/**
 * Manages server-sided sessions generated by the {@link sirius.web.http.WebServer}.
 */
@Register(classes = {SessionManager.class, EveryTenMinutes.class})
public class SessionManager implements EveryTenMinutes {

    /*
     * Default implementation which uses heap based maps for session storage
     */
    @Register(name = "memory")
    public static class MemorySessionStorage implements SessionStorage {

        private Map<String, MemoryServerSession> sessions = Maps.newConcurrentMap();

        protected void removeSession(MemoryServerSession serverSession) {
            sessions.remove(serverSession.getId());
        }

        @Override
        public Optional<ServerSession> getSession(String id) {
            return Optional.ofNullable(sessions.get(id)).map(Lambdas.touch(s -> s.access()));
        }

        @Override
        public ServerSession createSession() {
            MemoryServerSession result = new MemoryServerSession(this);
            sessions.put(result.getId(), result);

            return result;
        }

        @Override
        public Stream<String> getSessions() {
            return sessions.keySet().stream();
        }

        @Override
        public int getNumberOfSessions() {
            return sessions.size();
        }
    }

    @Part(configPath = "http.sessionStorage")
    private SessionStorage storage;

    @Parts(SessionListener.class)
    private static PartCollection<SessionListener> listeners;

    /**
     * Returns the session for the given id. Creates a new session, if currently non-existed.
     *
     * @param id session id of the requested session
     * @return the ServerSession associated with the given id
     */
    public Optional<ServerSession> getSession(@Nullable String id) {
        if (Strings.isEmpty(id)) {
            return Optional.empty();
        }
        return storage.getSession(id);
    }

    /**
     * Creates a new session.
     *
     * @return the newly created session
     */
    public ServerSession create() {
        ServerSession result = storage.createSession();
        listeners.forEach(l -> l.sessionCreated(result));
        return result;
    }

    /**
     * Returns a list of all available sessions
     *
     * @return the list of all active server sessions
     */
    public Stream<String> getSessions() {
        return storage.getSessions();
    }

    /**
     * Returns the total number of active sessions
     *
     * @return the number of sessions
     */
    public int getNumberOfSessions() {
        return storage.getNumberOfSessions();
    }

    @Override
    public void runTimer() throws Exception {
        // Remove all outdated sessions
        getSessions().map(k -> getSession(k).get())
                     .filter(s -> s != null)
                     .filter(s -> System.currentTimeMillis() - s.getLastAccessedTime()
                                  > TimeUnit.MILLISECONDS.convert(s.getMaxInactiveInterval(), TimeUnit.SECONDS))
                     .forEach(s -> {
                         listeners.forEach(l -> l.sessionInvalidated(s));
                         s.invalidate();
                     });
    }
}

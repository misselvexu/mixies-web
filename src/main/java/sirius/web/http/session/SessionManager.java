/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.web.http.session;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import sirius.kernel.async.Tasks;
import sirius.kernel.commons.Lambdas;
import sirius.kernel.commons.Strings;
import sirius.kernel.di.PartCollection;
import sirius.kernel.di.std.Part;
import sirius.kernel.di.std.Parts;
import sirius.kernel.di.std.Register;
import sirius.kernel.health.Exceptions;
import sirius.kernel.timer.EveryMinute;
import sirius.web.http.WebServer;

import javax.annotation.Nullable;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

/**
 * Manages server-sided sessions generated by the {@link sirius.web.http.WebServer}.
 */
@Register(classes = {SessionManager.class, EveryMinute.class})
public class SessionManager implements EveryMinute {

    /**
     * Default implementation which uses heap based maps for session storage
     */
    @Register(name = "memory")
    public static class MemorySessionStorage implements SessionStorage {

        private Map<String, MemoryServerSession> sessions = Maps.newConcurrentMap();

        protected void removeSession(MemoryServerSession serverSession) {
            sessions.remove(serverSession.getId());
        }

        @Override
        public Optional<ServerSession> getSession(String id) {
            return Optional.ofNullable(sessions.get(id)).map(Lambdas.touch(MemoryServerSession::access));
        }

        @Override
        public ServerSession findSession(String id) {
            return sessions.get(id);
        }

        @Override
        public ServerSession createSession() {
            MemoryServerSession result = new MemoryServerSession(this);
            sessions.put(result.getId(), result);

            return result;
        }

        @Override
        public Stream<String> getSessions() {
            return Lists.newArrayList(sessions.keySet()).stream();
        }

        @Override
        public int getNumberOfSessions() {
            return sessions.size();
        }
    }

    @Part(configPath = "http.sessionStorage")
    private SessionStorage storage;

    @Parts(SessionListener.class)
    private static PartCollection<SessionListener> listeners;

    /**
     * Returns the session for the given id. Creates a new session, if currently non-existed.
     * <p>
     * Marks the session as "accessed" which will most probably increase the lifespan of the
     * session.
     *
     * @param id session id of the requested session
     * @return the ServerSession associated with the given id
     */
    public Optional<ServerSession> getSession(@Nullable String id) {
        if (Strings.isEmpty(id)) {
            return Optional.empty();
        }
        return storage.getSession(id);
    }

    /**
     * Returns the existing session with the given ID, without marking it as "accessed".
     * <p>
     * This is mainly intended for monitoring and management tasks which access session without
     * increasing their lifetime.
     *
     * @param id the id of the session
     * @return the session with the given id or <tt>null</tt> if no such session exists
     */
    @Nullable
    public ServerSession findSession(String id) {
        return storage.findSession(id);
    }

    /**
     * Creates a new session.
     *
     * @return the newly created session
     */
    public ServerSession create() {
        ServerSession result = storage.createSession();
        listeners.forEach(l -> l.sessionCreated(result));
        return result;
    }

    /**
     * Returns a list of all available sessions
     *
     * @return the list of all active server sessions
     */
    public Stream<String> getSessions() {
        return storage.getSessions();
    }

    /**
     * Returns the total number of active sessions
     *
     * @return the number of sessions
     */
    public int getNumberOfSessions() {
        return storage.getNumberOfSessions();
    }

    @Part
    private Tasks tasks;

    @Override
    public void runTimer() throws Exception {
        tasks.defaultExecutor().fork(this::removeOutdatedSessions);
    }

    private void removeOutdatedSessions() {
        int sessions = storage.getNumberOfSessions();
        AtomicInteger sessionsInvalidated = new AtomicInteger();
        getSessions().map(k -> storage.findSession(k))
                     .filter(Objects::nonNull)
                     .filter(s -> System.currentTimeMillis() - s.getLastAccessedTime()
                                  > TimeUnit.MILLISECONDS.convert(s.getMaxInactiveInterval(), TimeUnit.SECONDS))
                     .forEach(s -> {
                         try {
                             s.invalidate();
                             listeners.forEach(l -> l.sessionInvalidated(s));
                             sessionsInvalidated.incrementAndGet();
                         } catch (Throwable e) {
                             Exceptions.handle(WebServer.LOG, e);
                         }
                     });
    }
}
